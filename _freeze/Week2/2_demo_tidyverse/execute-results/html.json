{
  "hash": "1c65b64d231e5010c4b6a33d735565f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n  html:\n    code-tools:\n      source: true\n---\n\n## Demo\n\nDownload this Demoscript via \"\\</\\>Code\" (top right)\n\nDepending on your knowledge of `R`, getting an overview of the data we imported last week might have been quite a challenge. Surprisingly enough, importing, cleaning and exploring your data can be the most challenging, time consuming part of a project. RStudio and the tidyverse offer many helpful tools to make this part easier (and more fun). You have read chapters on `dplyr` and `magrittr` as a preparation for this exercise. Before we start with the exercise however, this demo illustrates a simple approach offered by tidyverse which is applicable to sf-objects.\n\nAssume we want to calculate the timelag between subsequent positions. To achieve this we can use the function `difftime()` combined with `lead()` from `dplyr`. Let's look at these functions one by one.\n\n### `difftime` {#sec-difftime}\n\n`difftime` takes two `POSIXct` values.\n\n::: {.cell}\n\n```{.r .cell-code}\nnow <- as.POSIXct(\"2024-04-26 10:20:00\")\nlater <- as.POSIXct(\"2024-04-26 11:35:00\")\n\nlater\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-04-26 11:35:00 CEST\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntime_difference <- difftime(later, now)\n\ntime_difference\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 1.25 hours\n```\n\n\n:::\n:::\n\nYou can also specify the unit of the output.\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_difference <- difftime(later, now, units = \"secs\")\n\ntime_difference\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 4500 secs\n```\n\n\n:::\n:::\n\n`difftime` returns an object of the class `difftime`. \n\n::: {.cell}\n\n```{.r .cell-code}\nclass(time_difference)\n## [1] \"difftime\"\n\nstr(time_difference)\n##  'difftime' num 4500\n##  - attr(*, \"units\")= chr \"secs\"\n```\n:::\n\nHowever in our case, numeric values would be more handy than the class `difftime`. So we'll wrap the command in `as.numeric()`:\n\n::: {.cell}\n\n```{.r .cell-code}\ntime_difference <- as.numeric(difftime(later, now, units = \"secs\"))\n\nstr(time_difference)\n##  num 4500\nclass(time_difference)\n## [1] \"numeric\"\n```\n:::\n\nIn fact, we will use this exact operation multiple times, so let's create a function for this:\n\n::: {.cell}\n\n```{.r .cell-code}\ndifftime_secs <- function(later, now){\n    as.numeric(difftime(later, now, units = \"secs\"))\n}\n```\n:::\n\n### `lead()` / `lag()` {#sec-lead-lag}\n\n`lead()` and `lag()` return a vector of the same length as the input, just offset by a specific number of values (default is 1). Consider the following sequence:\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- 1:10\n\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n:::\n\nWe can now run `lead()` and `lag()` on this sequence to illustrate the output. `n =` specifies the offset, `default =` specifies the default value used to \"fill\" the emerging \"empty spaces\" of the vector. This helps us performing operations on subsequent values in a vector (or rows in a table).\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dplyr\")\n\nlead(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  2  3  4  5  6  7  8  9 10 NA\n```\n\n\n:::\n\n```{.r .cell-code}\nlead(numbers, n = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3  4  5  6  7  8  9 10 NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\nlag(numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] NA  1  2  3  4  5  6  7  8  9\n```\n\n\n:::\n\n```{.r .cell-code}\nlag(numbers, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] NA NA NA NA NA  1  2  3  4  5\n```\n\n\n:::\n\n```{.r .cell-code}\nlag(numbers, n = 5, default = 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 0 0 0 1 2 3 4 5\n```\n\n\n:::\n:::\n\n### `mutate()`\n\nUsing the above functions (`difftime()` and `lead()`), we can calculate the time lag, that is, the time difference between consecutive positions. We will try this on a dummy version of our wild boar dataset.\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein <- tibble(       # aka data.frame\n    TierID = rep(c(\"Hans\", \"Klara\"), each = 5),\n    DatetimeUTC = rep(as.POSIXct(\"2015-01-01 00:00:00\", tz = \"UTC\") + 0:4 * 15 * 60, 2)\n)\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 2\n   TierID DatetimeUTC        \n   <chr>  <dttm>             \n 1 Hans   2015-01-01 00:00:00\n 2 Hans   2015-01-01 00:15:00\n 3 Hans   2015-01-01 00:30:00\n 4 Hans   2015-01-01 00:45:00\n 5 Hans   2015-01-01 01:00:00\n 6 Klara  2015-01-01 00:00:00\n 7 Klara  2015-01-01 00:15:00\n 8 Klara  2015-01-01 00:30:00\n 9 Klara  2015-01-01 00:45:00\n10 Klara  2015-01-01 01:00:00\n```\n\n\n:::\n:::\n\n\nIf we are interested to calculate the speed travelled between subsequent locations, we need to calculate the elapsed time first. Since R does most operations in a vectorized manner, we can use `difftime_secs` on the entire column `DatetimeUTC` of our dataframe `wildschwein` and store the output in a new column. \n\n::: {.cell}\n\n```{.r .cell-code}\nnow <- wildschwein$DatetimeUTC\nlater <- lead(now)\n\n# View(wildschwein)\n\nwildschwein$timelag <- difftime_secs(later, now)\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00     900\n 2 Hans   2015-01-01 00:15:00     900\n 3 Hans   2015-01-01 00:30:00     900\n 4 Hans   2015-01-01 00:45:00     900\n 5 Hans   2015-01-01 01:00:00   -3600\n 6 Klara  2015-01-01 00:00:00     900\n 7 Klara  2015-01-01 00:15:00     900\n 8 Klara  2015-01-01 00:30:00     900\n 9 Klara  2015-01-01 00:45:00     900\n10 Klara  2015-01-01 01:00:00      NA\n```\n\n\n:::\n:::\n\nHowever, we have an issue at the transition between the two animals. We can overcome this issue using dplyr's `mutate` with `group_by`. **If we use `mutate`, we do not use the `$` notation!**\n\n::: {.cell}\n\n```{.r .cell-code}\n# note the lack of \"$\"\nwildschwein <- mutate(wildschwein, timelag = difftime_secs(lead(DatetimeUTC), DatetimeUTC))\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00     900\n 2 Hans   2015-01-01 00:15:00     900\n 3 Hans   2015-01-01 00:30:00     900\n 4 Hans   2015-01-01 00:45:00     900\n 5 Hans   2015-01-01 01:00:00   -3600\n 6 Klara  2015-01-01 00:00:00     900\n 7 Klara  2015-01-01 00:15:00     900\n 8 Klara  2015-01-01 00:30:00     900\n 9 Klara  2015-01-01 00:45:00     900\n10 Klara  2015-01-01 01:00:00      NA\n```\n\n\n:::\n:::\n\nThe output is equivalent, we need `group_by` as well.\n\n### `group_by()`\n\nTo distinguish groups in a dataframe, we need to specify these using `group_by()`. \n\n::: {.cell}\n\n```{.r .cell-code}\n# again, note the lack of \"$\"\nwildschwein <- group_by(wildschwein, TierID)\n```\n:::\n\nAfter adding this grouping variable, calculating the `timelag` automatically accounts for the individual trajectories.\n\n::: {.cell}\n\n```{.r .cell-code}\n# again, note the lack of \"$\"\nwildschwein <- mutate(wildschwein, timelag = difftime_secs(lead(DatetimeUTC), DatetimeUTC))\n\nwildschwein\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n# Groups:   TierID [2]\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00     900\n 2 Hans   2015-01-01 00:15:00     900\n 3 Hans   2015-01-01 00:30:00     900\n 4 Hans   2015-01-01 00:45:00     900\n 5 Hans   2015-01-01 01:00:00      NA\n 6 Klara  2015-01-01 00:00:00     900\n 7 Klara  2015-01-01 00:15:00     900\n 8 Klara  2015-01-01 00:30:00     900\n 9 Klara  2015-01-01 00:45:00     900\n10 Klara  2015-01-01 01:00:00      NA\n```\n\n\n:::\n:::\n\n\n### Piping \n\nPiping can simplify the process and help us write our sequence of operations in a manner as we would explain them to another human being.\n\nIn order to make code readable in a more human-friendly way, we can use the piping command (`|>` or `%>%`, it does not matter which).\n\n::: {.cell}\n\n```{.r .cell-code}\nwildschwein |>                                            # Take wildschwein...\n    group_by(TierID) |>                                   # ...group it by TierID\n    mutate(\n        timelag = difftime_secs(lead(DatetimeUTC), DatetimeUTC)# Caculate difftime\n        )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n# Groups:   TierID [2]\n   TierID DatetimeUTC         timelag\n   <chr>  <dttm>                <dbl>\n 1 Hans   2015-01-01 00:00:00     900\n 2 Hans   2015-01-01 00:15:00     900\n 3 Hans   2015-01-01 00:30:00     900\n 4 Hans   2015-01-01 00:45:00     900\n 5 Hans   2015-01-01 01:00:00      NA\n 6 Klara  2015-01-01 00:00:00     900\n 7 Klara  2015-01-01 00:15:00     900\n 8 Klara  2015-01-01 00:30:00     900\n 9 Klara  2015-01-01 00:45:00     900\n10 Klara  2015-01-01 01:00:00      NA\n```\n\n\n:::\n:::\n\n### `summarise()`\n\nIf we want to summarise our data and get metrics *per animal*, we can use the `dplyr` function `summarise()`. In contrast to `mutate()`, which just adds a new column to the dataset, `summarise()` \"collapses\" the data to one row per individual (specified by `group_by`).\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(wildschwein, mean = mean(timelag, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  TierID  mean\n  <chr>  <dbl>\n1 Hans     900\n2 Klara    900\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}