{
  "hash": "952b572d560069aa8dc41334a731923e",
  "result": {
    "engine": "knitr",
    "markdown": "## Tasks and inputs\n\n\n\nUp to now, we have used a variety of different functions designed by other developers. Sometimes we need to execute an operation multiple times, and most often it is reasonable to write a function to do so. Whenever you have copied and pasted a block of code more than twice, you should consider writing a function [@wickham2023]. \n\nThe first step in writing a function, is picking a name and assigning `<- function(){}` to it.\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- function() {}\n```\n:::\n\nTo run the function, we have to call the assigned name with the brackets. The function `testfun` gives no output, which is why we get `NULL` back. \n::: {.cell}\n\n```{.r .cell-code}\ntestfun()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(testfun)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n:::\n\nTo make the function actually *do* something, we need to specify *what* should be done within the curly brackets `{}`. The following function always prints the same statement and accepts no input values:\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- function() {\n    print(\"this function does nothing\")\n}\n\ntestfun()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this function does nothing\"\n```\n\n\n:::\n:::\n\nIf we want the function to accept some input values, we have to define them within the round brackets. For example, I specify a variable named `sometext` and can call this variable within the execution.\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- function(sometext) {\n    print(sometext)\n}\n\ntestfun(sometext = \"this function does slightly more, but still not much\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this function does slightly more, but still not much\"\n```\n\n\n:::\n:::\n\n:::{.callout-note collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- function(sometext) {\n    print(sometext)\n}\n```\n:::\n\nNote that since R Version 4.1, the above syntax can also be written as follows:\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- \\(sometext){\n    print(sometext)\n}\n```\n:::\n\nor even more compact:\n\n::: {.cell}\n\n```{.r .cell-code}\ntestfun <- \\(sometext) print(sometext)\n```\n:::\n:::\n\nLet's take a more practical example. Say we want a function that calculates our age if provided with the date of our birthday. We can use `Sys.time()` to provide today's date and `difftime()` to calculate the time difference between today and our birthday.\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_age <- function(birthday, output_unit) {\n    difftime(Sys.time(), birthday, units = output_unit)\n}\n\nmy_age(birthday = \"1997-04-23\", output_unit = \"days\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 10192.43 days\n```\n\n\n:::\n:::\n\nAs we already know from using other functions, if we declare our variables in the order that we initially listed them, we do not need to specify the parameters (no need of `birthday = ` and `output_unit =`).\n::: {.cell}\n\n```{.r .cell-code}\nmy_age(\"1997-04-23\", \"days\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 10192.43 days\n```\n\n\n:::\n:::\n\nIf we want any of our parameters to have default value, we can assign an initial value to the parameter when declaring the variables within the round brackets.\n::: {.cell}\n\n```{.r .cell-code}\nmy_age <- function(birthday, output_unit = \"days\") {\n    difftime(Sys.time(), birthday, units = output_unit)\n}\n\n# if not stated otherwise, our function uses the unit \"days\"\nmy_age(\"1997-04-23\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 10192.43 days\n```\n\n\n:::\n\n```{.r .cell-code}\n# We can still overwrite units\nmy_age(\"1997-04-23\", \"hours\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 244618.3 hours\n```\n\n\n:::\n:::\n\nAll you need to do now is run execute the function deceleration (`myage <- function...` etc.) at the beginning of your script, and you can use the function for your entire R session. \n\n:::{.callout-important}\nAlways try to make your function self sufficient: Only use objects within your function that are either passed as function arguments or created within the funtion. See more on this topic [here](https://raps-with-r.dev/fprog.html#referentially-transparent-and-pure-functions), in the online version of the book by @rodrigues2023.\n:::\n\n### Task 1: Write your own functions\n\nCreate the following two functions:\n\n1. A function which calculates a persons BMI based on their height and weight ($\\text{BMI} = \\frac{\\text{Weight (kg)}}{\\text{Height (m)}^2}$)\n2. A function which converts degrees Celcius to Farenheight ($\\text{Farenheight} = \\text{Celcius} \\times \\frac{9}{5} + 32$)\n3. A function which calculates the (Euclidean) distance between two sets of coordinates ($x_1$, $y_1$ and $x_2$, $y_2$) based on the formula below:\n\n$$\\text{Euclidean distance} = \\sqrt{(x_2 - x_1)^2+(y_2 - y_1)^2}$$\n\n### Task 2: Prepare Analysis\n\nIn the next tasks we will look for \"meet\" patterns in our wild boar data. To simplify this, we will only use a subset of our wild boar data: The individuals *Rosa* and *Sabi* for the timespan *01.04.2015 - 15.04.2015*. You can download the dataset from moodle. Import the csv as a data.frame and filter it with the aforementioned criteria. You do not need to convert the data.frame to an `sf` object. \n\n\n\n::: {.cell}\n\n:::\n\n### Task 3: Create Join Key\n\nHave a look at your dataset. You will notice that samples are taken at every full hour, quarter past, half past and quarter to. The sampling time is usually off by a couple of seconds. \n\nTo compare Rosa and Sabi's locations, we first need to match the two animals *temporally*. For that we can use a `join`, but need *identical* time stamps to serve as a join key. We therefore need to slightly adjust our time stamps to a common, concurrent interval. \n\nThe task is therfore to round the minutes of `DatetimeUTC` to a multiple of 15 (00, 15, 30,45) and store the values in a new column[^interpolate]. You can use the  `lubridate` function `round_date()` for this. See the examples [here](https://lubridate.tidyverse.org/reference/round_date.html) to see how this goes.\n\n[^interpolate]: *Please note:* We are manipulating our time stamps without adjusting the x,y-coordinates. This is fine for our simple example, but we would advice against this in a more serious research endeavour, e.g. in your semester projects. One simple approach would be to linearly interpolate the positions to the new timestamps. If you choose Option A the wild boar projects as your semester projects, you should aim for a linear interpolation. Get in touch if you need help with this.\n\nYour new dataset should look something like this (note the additional column): \n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 7\n# Groups:   TierID [1]\n  TierID TierName CollarID DatetimeUTC              E      N DatetimeRound      \n  <chr>  <chr>       <dbl> <dttm>               <dbl>  <dbl> <dttm>             \n1 002A   Sabi        12275 2015-04-01 00:00:11 2.57e6 1.21e6 2015-04-01 00:00:00\n2 002A   Sabi        12275 2015-04-01 00:15:22 2.57e6 1.21e6 2015-04-01 00:15:00\n3 002A   Sabi        12275 2015-04-01 00:30:11 2.57e6 1.21e6 2015-04-01 00:30:00\n4 002A   Sabi        12275 2015-04-01 00:45:16 2.57e6 1.21e6 2015-04-01 00:45:00\n5 002A   Sabi        12275 2015-04-01 01:00:44 2.57e6 1.21e6 2015-04-01 01:00:00\n6 002A   Sabi        12275 2015-04-01 01:15:17 2.57e6 1.21e6 2015-04-01 01:15:00\n```\n\n\n:::\n:::\n\n### Task 4: Measuring distance at concurrent locations\n\nTo measure the distance between concurrent locations, we need to follow the following steps.\n\n1. Split the `wildschwein_filter` object into one `data.frame` per animal\n2. Join\\* these datasets by the new `Datetime` column created in the last task. The joined observations are *temporally close*.\n3. In the joined dataset, calculate Euclidean distances between concurrent observations and store the values in a new column\n4. Use a reasonable threshold on `distance` to determine if the animals are also *spatially close* enough to constitute a *meet* (we use 100 meters). Store this Boolean information (`TRUE`/`FALSE`) in a new column\n\n\\* We recommend using one `dplyr`s join methods (`inner_join()`, `left_join()`, `right_join()` or `full_join()`), which one is appropriate? Tip: specify `suffix` to prevent column names ending in `.x` or `.y`.\n\n::: {.cell}\n\n:::\n\n### Task 5: Visualize data\n\nNow, visualize the *meets* spatially in a way that you think reasonable. For example in the plot as shows below. To produce this plot we:\n\n- Used the individual dataframes from `rosa` and `sabi` (from the previous task)\n- Used the joined dataset (also from the previous task), filtered to only the meets\n- Manually changed the x and y axis limits\n\n::: {.cell}\n::: {.cell-output-display}\n![](2_tasks_and_inputs_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n### Task 6 (optional): Visualize data as timecube with `plotly`\n\nFinally, you can nicely visualize the meeting patterns and trajectories in a Space-Time-Cube [@hagerstraand1970] with the package `plotly`. There are some [nice ressources](https://plot.ly/r/3d-line-plots/) available online.\n\n![](../02_Images/space_time_cube.jpg)\n\n\n\n\n### Submission\n\nTo submit your exercise, provide us with the URL of your Github repo as described [in the preperation](#sec-github-repo).\n\nYou can give other GitHub users write access to your repository throught the repository settings. You will be needing this for your semester project. To practice this, add Dominic ([\\@DLND8](https://github.com/DLND8/)) and Nils ([\\@ratnanil](https://github.com/ratnanil/)) to your GitHub repo: \n\n1. Go to your GitHub repository on GitHub.com\n2. Go to the repository settings by clicking on the *Settings* tab\n3. In the left panel, click on *Collaborators and teams* and then *Add people*\n4. Add the mentioned Persons via their GitHub Usernames, give them *Write* privilages. \n",
    "supporting": [
      "2_tasks_and_inputs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../site_libs/plotly-binding-4.10.4/plotly.js\"></script>\n<script src=\"../site_libs/typedarray-0.1/typedarray.min.js\"></script>\n<script src=\"../site_libs/jquery-3.5.1/jquery.min.js\"></script>\n<link href=\"../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n<link href=\"../site_libs/plotly-htmlwidgets-css-2.11.1/plotly-htmlwidgets.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/plotly-main-2.11.1/plotly-latest.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}