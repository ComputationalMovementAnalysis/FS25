{
  "hash": "14bd55c6e65d9f4526e893263600b2d1",
  "result": {
    "engine": "knitr",
    "markdown": "## Solutions\n\n:::{.callout-tip}\nHover over the code and copy the content by clicking on the clipboard icon on the top right. You can now paste this into an R-Script.\n:::\n\nThe code examples for task 1 - 4 was done using a posmo dataset. If you used another dataset (Strava, Google Timeline, etc.) your code can look a bit different.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```{.sourceCode .r}\n# task_1.R\n################################################################################\n\n\n\nlibrary(\"dplyr\")   # move this to the top of your script\nlibrary(\"ggplot2\") # move this to the top of your script\nlibrary(\"readr\")   # move this to the top of your script\nlibrary(\"sf\")      # move this to the top of your script\n\nposmo <- read_delim(\"datasets/posmo_2022-05-01T00 00 00+02 00-2023-04-18T23 59 59+02 00.csv\") |>\n    st_as_sf(coords = c(\"X\", \"Y\"), crs = 2056, remove = FALSE) |>\n\nposmo_filter <- posmo |>\n    filter(as.Date(datetime) == \"2023-03-23\")\n\ndistance_by_element <- function(later, now) {\n  as.numeric(\n    st_distance(later, now, by_element = TRUE)\n  )\n}\n\nposmo_filter <- posmo_filter |>\n  mutate(\n    stepMean = rowMeans(\n      cbind(\n        distance_by_element(lag(geometry, 3), geometry),\n        distance_by_element(lag(geometry, 2), geometry),\n        distance_by_element(lag(geometry, 1), geometry),\n        distance_by_element(geometry, lead(geometry, 1)),\n        distance_by_element(geometry, lead(geometry, 2)),\n        distance_by_element(geometry, lead(geometry, 3))\n      )\n    )\n  )\n\n# Note:\n# We present here a slightly different approach as presented in the input:\n# - cbind() creates a matrix with the same number of rows as the original dataframe\n# - It has 6 columns, one for each Euclidean distance calculation\n# - rowMeans() returns a single vector with the same number of rows as the original dataframe\n\n\n\n\n# task_2.R\n################################################################################\n\n\nsummary(posmo_filter$stepMean)\n\nggplot(posmo_filter, aes(stepMean)) +\n  geom_histogram(binwidth = 1) +\n  geom_vline(xintercept = mean(posmo_filter$stepMean, na.rm = TRUE))\n\nposmo_filter <- posmo_filter |>\n  mutate(\n    static = stepMean < mean(posmo_filter$stepMean, na.rm = TRUE)\n  )\n\n\n\n\n# task_3.R\n################################################################################\n\n\nposmo_filter |>\n  ggplot() +\n  geom_path(aes(X, Y), alpha = 0.5) +\n  geom_point(aes(X, Y, colour = static)) +\n  theme_minimal() +\n  coord_equal()\n\n\n\n\n# task_4.R\n################################################################################\n\n\nposmo_filter <- posmo_filter |>\n  mutate(\n    segment_ID = rle_id(static)\n  )\n\nposmo_filter_moves <- posmo_filter |>\n  filter(!static)\n\np1 <- ggplot(posmo_filter_moves, aes(X, Y, color = segment_ID)) +\n  geom_point() +\n  geom_path() +\n  coord_equal() +\n  theme(legend.position = \"none\") +\n  labs(subtitle = \"All segments (uncleaned)\")\n\np2 <- posmo_filter_moves |>\n  group_by(segment_ID) |>\n  mutate(duration = as.integer(difftime(max(datetime), min(datetime), \"mins\"))) |>\n  filter(duration > 5) |>\n  ggplot(aes(X, Y, color = segment_ID)) +\n  geom_point() +\n  geom_path() +\n  coord_equal() +\n  theme(legend.position = \"none\") +\n  labs(subtitle = \"Long segments (removed segements <5 minutes)\")\n\n\n\n\n# task_5.R\n################################################################################\n\n\npedestrians <- read_delim(\"datasets/pedestrian.csv\", \",\")\n\nggplot(pedestrians, aes(E, N)) +\n  geom_point(data = dplyr::select(pedestrians, -TrajID), alpha = 0.1) +\n  geom_point(aes(color = as.factor(TrajID)), size = 2) +\n  geom_path(aes(color = as.factor(TrajID))) +\n  facet_wrap(~TrajID, labeller = label_both) +\n  coord_equal() +\n  theme_minimal() +\n  labs(title = \"Visual comparison of the 6 trajectories\", subtitle = \"Each subplot highlights a trajectory\") +\n  theme(legend.position = \"none\", axis.text = element_blank())\n\n\n\n\n# task_6.R\n################################################################################\n\n\nlibrary(\"SimilarityMeasures\")  # move this to the top of your script\n# for the similarity measure functions\n\n# all functions compare two trajectories (traj1 and traj2). Each trajectory\n# must be an numeric matrix of n dimensions. Since our dataset is spatiotemporal\n# we need to turn our Datetime column from POSIXct to integer:\n\npedestrians <- pedestrians |>\n  mutate(Datetime_int = as.integer(DatetimeUTC))\n\n# Next, we make an object for each trajectory only containing the\n# coordinates in the three-dimensional space and turn it into a matrix\n\ntraj1 <- pedestrians |>\n  filter(TrajID == 1) |>\n  dplyr::select(E, N, Datetime_int) |>\n  as.matrix()\n\n# But instead of repeating these lines 6 times, we turn them into a function.\n# (this is still more repetition than necessary, use the purr::map if you know\n# how!)\n\ndf_to_traj <- function(df, traj) {\n  df |>\n    filter(TrajID == traj) |>\n    dplyr::select(E, N, Datetime_int) |>\n    as.matrix()\n}\n\ntraj2 <- df_to_traj(pedestrians, 2)\ntraj3 <- df_to_traj(pedestrians, 3)\ntraj4 <- df_to_traj(pedestrians, 4)\ntraj5 <- df_to_traj(pedestrians, 5)\ntraj6 <- df_to_traj(pedestrians, 6)\n\n# Then we can start comparing trajectories with each other\n\ndtw_1_2 <- DTW(traj1, traj2)\ndtw_1_3 <- DTW(traj1, traj3)\n\n# ... and so on. Since this also leads to much code repetition, we will\n# demostrate a diffferent approach:\n\n# Instead of creating 6 objects, we can also create a single list containing 6\n# elements by using \"split\" and \"purrr::map\"\n\nlibrary(purrr)\n\npedestrians_list <- map(1:6, function(x) {\n  df_to_traj(pedestrians, x)\n})\n\ncomparison_df <- map_dfr(2:6, function(x) {\n  tibble(\n    trajID = x,\n    DTW = DTW(pedestrians_list[[1]], pedestrians_list[[x]]),\n    EditDist = EditDist(pedestrians_list[[1]], pedestrians_list[[x]]),\n    Frechet = Frechet(pedestrians_list[[1]], pedestrians_list[[x]]),\n    LCSS = LCSS(pedestrians_list[[1]], pedestrians_list[[x]], 5, 4, 4)\n  )\n})\n\nlibrary(tidyr) # for pivot_longer\n\ncomparison_df |>\n  pivot_longer(-trajID) |>\n  ggplot(aes(trajID, value, fill = as.factor(trajID))) +\n  geom_bar(stat = \"identity\") +\n  facet_wrap(~name, scales = \"free\") +\n  theme(legend.position = \"none\") +\n  labs(x = \"Comparison trajectory\", y = \"Value\", title = \"Computed similarities using different measures \\nbetween trajectory 1 to all other trajectories \")\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}