{
  "hash": "f22063eda58b38d94364ca8deb0c1ee9",
  "result": {
    "engine": "knitr",
    "markdown": "### Input: Segmentation {#sec-input-segmentation}\n\nYou've read @laube2011 about segmenting trajectories. In the paper, the authors define \"*static*\" fixes as \"*those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d*\", as illustrated in @fig-laubeimg\n\n\n:::{#fig-laubeimg}\n\n![](../02_Images/laube_2011.jpg)\n\nThe figure from @laube2011 visualizes steps a) zu d), which will be explained below\n\n:::\n\n(a) Specify a temporal windows $v$ for in which to measure Euclidean distances.\n(b) Measure the distance from every point to every other point within this temporal window $v$.\n(c) Remove \"static points\": These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories.\n(d) Now remove short subtrajectories: These are trajectories with a short duration (whereas \"short\" is tbd).\n\nWe will **demonstrate** implementing this method on the wild boar \"Sabi\", restricting ourselves to a couple of tracking days. Your task will be to understand this implementation and apply it to your own movement data. \n\nOpen a RStudio Project for this week. Next, copy the wild boar data you downloaded last week (*wildschwein_BE_2056.csv*) to your project folder. If you cannot find this dataset on your computer, you can re-download it from moodle. Transform the data into an `sf` object, filter for the wild boar Sabi and a datetime between \"2015-07-01\" and \"2015-07-03\".\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"readr\")\n\nwildschwein <- read_delim(\"datasets/wildschwein_BE_2056.csv\", \",\")\n\n\nlibrary(\"sf\")\nlibrary(\"dplyr\")\n\n# Careful! What Timezone is assumed?\nsabi <- wildschwein |>\n    st_as_sf(coords = c(\"E\", \"N\"), crs = 2056, remove = FALSE) |>\n    filter(\n      TierName == \"Sabi\", \n      DatetimeUTC >= \"2015-07-01\", \n      DatetimeUTC < \"2015-07-03\"\n      )\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Movement of the wild boar 'Sabi' in the timespan 01 - 02.07.2015. The cluster of dots / fixes are possible 'static' points](1_input_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n#### Step a): Specify a temporal window $v$ {#sec-segmentation-a}\n\nIn the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):\n\n1. `pos[n-2]` to `pos[n]`\n2. `pos[n-1]` to `pos[n]`\n3. `pos[n]` to `pos[n+1]`\n4. `pos[n]` to `pos[n+2]`\n\n#### Step b): Measure the distance to every point within $v$  {#sec-segmentation-b}\n\nWe can use the function distance_by_element from week 2 in combination with `lead()` and `lag()` to calculate the Euclidean distance. For example, to create the necessary offset of n-2, we use `lag(x, 2)`. For each offset, we create one individual column.\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_by_element <- function(later, now) {\n  as.numeric(\n    st_distance(later, now, by_element = TRUE)\n  )\n}\n\n\nsabi <- sabi |>\n    mutate(\n        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  # distance to pos -30 minutes\n        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  # distance to pos -15 minutes\n        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), # distance to pos +15 mintues\n        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  # distance to pos +30 minutes\n    )\n```\n:::\n\nNow we want to calculate the mean distance of `nMinus2`, `nMinus1`, `nPlus1`, `nPlus2` for each row. Since we want the mean value *per Row*, we have to explicitly specify this before `mutate()` with the function `rowwise()`. To remove this rowwise-grouping, we end the operation with `ungroup()`. \n\nNote that for the first two positions, we cannot calculate a `stepMean` since there is no Position `n-2` for these positions. This is also true for the last to positions (lacking a position `n+2`).\n\n::: {.cell}\n\n```{.r .cell-code}\nsabi <- sabi |>\n    rowwise() |>\n    mutate(\n        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))\n    ) |>\n    ungroup()\n\nsabi\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 192 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2569724 ymin: 1204916 xmax: 2570927 ymax: 1205957\nProjected CRS: CH1903+ / LV95\n# A tibble: 192 × 12\n   TierID TierName CollarID DatetimeUTC                E        N\n   <chr>  <chr>       <dbl> <dttm>                 <dbl>    <dbl>\n 1 002A   Sabi        12275 2015-06-30 22:00:13 2569972. 1205366.\n 2 002A   Sabi        12275 2015-06-30 22:16:06 2569975. 1205637.\n 3 002A   Sabi        12275 2015-06-30 22:30:19 2570266. 1205857.\n 4 002A   Sabi        12275 2015-06-30 22:45:13 2570208. 1205913.\n 5 002A   Sabi        12275 2015-06-30 23:00:10 2570247. 1205731.\n 6 002A   Sabi        12275 2015-06-30 23:15:17 2570512. 1205279.\n 7 002A   Sabi        12275 2015-06-30 23:30:38 2570684. 1205103.\n 8 002A   Sabi        12275 2015-06-30 23:45:16 2570526. 1205051.\n 9 002A   Sabi        12275 2015-07-01 00:00:10 2570532. 1205044.\n10 002A   Sabi        12275 2015-07-01 00:15:14 2570530. 1205059.\n# ℹ 182 more rows\n# ℹ 6 more variables: geometry <POINT [m]>, nMinus2 <dbl>, nMinus1 <dbl>,\n#   nPlus1 <dbl>, nPlus2 <dbl>, stepMean <dbl>\n```\n\n\n:::\n:::\n\n#### Step c): Remove \"static points\"  {#sec-segmentation-c}\n\nWe can now determine if an animal is moving or not by specifying a threshold distance on `stepMean`. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.\n\n::: {.cell}\n\n```{.r .cell-code}\nsabi <- sabi |>\n    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))\n\nsabi_filter <- sabi |>\n    filter(!static)\n\nsabi_filter |>\n    ggplot(aes(E, N)) +\n    geom_point(data = sabi, col = \"red\") +\n    geom_path() +\n    geom_point() +\n    coord_fixed() +\n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![The trajectory of sabi. Red dots are static points, the black dots signify moving points](1_input_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n",
    "supporting": [
      "1_input_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}