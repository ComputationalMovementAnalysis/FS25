{
  "hash": "95827dea08dd03d0be06e0f1852baba1",
  "result": {
    "engine": "knitr",
    "markdown": "## Exercise A: Segmentation\n\nWith the skills from @sec-input-segmentation you can now implement the segmentation algorithm described in @laube2011 to either your own movement data or to a different wild boar using different sampling intervals. \n\n:::{.callout-note collapse=\"true\"}\n\n## If you use Git...\n\nOnce you have completed this prepartions, commit your changes with a meaningful commit message. *Before committing, make sure your location data is ignored!* Then, test your connection to Github by pushing your changes to your remote repository.\n\n:::\n\n### Task 1: Calculate distances\n\n\nNow, you can @sec-segmentation-a and @sec-segmentation-b, which you had used with *sabi*, on on your own movement data or to a different wild boar using different sampling intervals.\n\n\n:::{.callout-note collapse=\"true\"}\n\n## If you use Git...\n\nOnce you have completed the task, commit your changes with a meaningful commit message and test your connection to Github by pushing your changes to your remote repository.\n\n:::\n\n### Task 2: Specify and apply threshold *d*\n\nAfter calculating the Euclidean distances to positions within the temporal window *v* in task 1, you can explore these values (we stored them in the column `stepMean`) using summary statistics (histograms, boxplot, `summary()`): This way we can define a reasonable threshold value to differentiate between *stops* and *moves*. There is no \"correct\" way of doing this, specifying a threshold always depends on data as well as the question that needs to be answered. In this exercise, use the mean of all `stepMean` values.\n\nStore the new information (boolean to differentiate between stops (`TRUE`) and moves (`FALSE`)) in a new column named `static`.\n\n:::{.callout-note collapse=\"true\"}\n\n## If you use Git...\n\nCommit your changes with a meaningful commit message. \n\n\n:::\n\n### Task 3: Visualize segmented trajectories\n\nNow visualize the segmented trajectory spatially. Just like last week, you can use ggplot with `geom_path()`, `geom_point()` and `coord_equal()`. Assign `colour = static` within `aes()` to distinguish between segments *with* \"movement\" and *without*.\n\n:::{.callout-note collapse=\"true\"}\n\n## If you use Git...\n\nCommit your changes with a meaningful commit message. \n\n\n:::\n\n### Task 4: Segment-based analysis\n\nIn applying @laube2011, we've come as far as step b) in @fig-laubeimg. In order to complete the last steps (c and d), we need a *unique* ID for each segment that we can use as a grouping variable. The following function does just that (it assigns unique IDs based on the column `static` which you created in Task 2). You will learn about functions next week. For now, just copy the following code chunk into your script and run it.\n\n::: {.cell}\n\n```{.r .cell-code}\nrle_id <- function(vec) {\n    x <- rle(vec)$lengths\n    as.factor(rep(seq_along(x), times = x))\n}\n```\n:::\n\nYou can use the newly created function `rle_id` to assign unique IDs to subtrajectories (as shown below). Visualize the *moving* segments by colourizing them by `segment_ID`. \nThen use `segment_ID` as a grouping variable to determine the segments duration and remove short segments (e.g. segments with a duration < 5 Minutes) \n\n::: {.cell}\n\n```{.r .cell-code}\nyour_data_frame <- your_data_frame |>\n    mutate(segment_id = rle_id(static))\n```\n:::\n\n:::{.callout-note collapse=\"true\"}\n\n## If you use Git...\n\nCommit your changes with a meaningful commit message. \n\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}