### Input: Segmentation {#sec-input-segmentation}

You've read @laube2011 about segmenting trajectories. In the paper, the authors define "*static*" fixes as "*those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d*", as illustrated in @fig-laubeimg


:::{#fig-laubeimg}

![](../02_Images/laube_2011.jpg)

The figure from @laube2011 visualizes steps a) zu d), which will be explained below

:::

(a) Specify a temporal windows $v$ for in which to measure Euclidean distances.
(b) Measure the distance from every point to every other point within this temporal window $v$.
(c) Remove "static points": These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories.
(d) Now remove short subtrajectories: These are trajectories with a short duration (whereas "short" is tbd).

We will **demonstrate** implementing this method on the wild boar "Sabi", restricting ourselves to a couple of tracking days. Your task will be to understand this implementation and apply it to your own movement data. 

Open a RStudio Project for this week. Next, copy the wild boar data you downloaded last week (*wildschwein_BE_2056.csv*) to your project folder. If you cannot find this dataset on your computer, you can re-download it from moodle. Transform the data into an `sf` object, filter for the wild boar Sabi and a datetime between "2015-07-01" and "2015-07-03".

```{r}
#| echo: true

library("readr")

wildschwein <- read_delim("datasets/wildschwein_BE_2056.csv", ",")


library("sf")
library("dplyr")

# Careful! What Timezone is assumed?
sabi <- wildschwein |>
    st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>
    filter(
      TierName == "Sabi", 
      DatetimeUTC >= "2015-07-01", 
      DatetimeUTC < "2015-07-03"
      )
```

```{r}
#| echo: false
#| fig.cap: "Movement of the wild boar 'Sabi' in the timespan 01 - 02.07.2015. The cluster of dots / fixes are possible 'static' points"

library("ggplot2")

ggplot(sabi, aes(E, N)) +
    geom_point(alpha = .5) +
    geom_path(alpha = .5) +
    coord_fixed() +
    guides(color = guide_colorbar(title.position = "top", title.hjust = .5, barwidth = unit(20, "lines"), barheight = unit(.5, "lines"))) +
    theme(legend.position = "bottom") 
```

#### Step a): Specify a temporal window $v$ {#sec-segmentation-a}

In the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):

1. `pos[n-2]` to `pos[n]`
2. `pos[n-1]` to `pos[n]`
3. `pos[n]` to `pos[n+1]`
4. `pos[n]` to `pos[n+2]`

#### Step b): Measure the distance to every point within $v$  {#sec-segmentation-b}

We can use the function distance_by_element from week 2 in combination with `lead()` and `lag()` to calculate the Euclidean distance. For example, to create the necessary offset of n-2, we use `lag(x, 2)`. For each offset, we create one individual column.

```{r}
#| echo: true

distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}


sabi <- sabi |>
    mutate(
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  # distance to pos -30 minutes
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  # distance to pos -15 minutes
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), # distance to pos +15 mintues
        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  # distance to pos +30 minutes
    )
```

Now we want to calculate the mean distance of `nMinus2`, `nMinus1`, `nPlus1`, `nPlus2` for each row. Since we want the mean value *per Row*, we have to explicitly specify this before `mutate()` with the function `rowwise()`. To remove this rowwise-grouping, we end the operation with `ungroup()`. 

Note that for the first two positions, we cannot calculate a `stepMean` since there is no Position `n-2` for these positions. This is also true for the last to positions (lacking a position `n+2`).

```{r}
#| echo: true

sabi <- sabi |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

sabi
```

#### Step c): Remove "static points"  {#sec-segmentation-c}

We can now determine if an animal is moving or not by specifying a threshold distance on `stepMean`. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.

```{r}
#| echo: true
#| fig.cap: "The trajectory of sabi. Red dots are static points, the black dots signify moving points"

sabi <- sabi |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_filter <- sabi |>
    filter(!static)

sabi_filter |>
    ggplot(aes(E, N)) +
    geom_point(data = sabi, col = "red") +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```



