## Exercise A: Segmentation

With the skills from @sec-input-segmentation you can now implement the segmentation algorithm described in @laube2011 to either your own movement data or to a different wild boar using different sampling intervals. 

:::{.callout-note collapse="true"}

## If you use Git...

Once you have completed this prepartions, commit your changes with a meaningful commit message. *Before committing, make sure your location data is ignored!* Then, test your connection to Github by pushing your changes to your remote repository.

:::

### Task 1: Calculate distances


Now, you can @sec-segmentation-a and @sec-segmentation-b, which you had used with *sabi*, on on your own movement data or to a different wild boar using different sampling intervals.


:::{.callout-note collapse="true"}

## If you use Git...

Once you have completed the task, commit your changes with a meaningful commit message and test your connection to Github by pushing your changes to your remote repository.

:::

### Task 2: Specify and apply threshold *d*

After calculating the Euclidean distances to positions within the temporal window *v* in task 1, you can explore these values (we stored them in the column `stepMean`) using summary statistics (histograms, boxplot, `summary()`): This way we can define a reasonable threshold value to differentiate between *stops* and *moves*. There is no "correct" way of doing this, specifying a threshold always depends on data as well as the question that needs to be answered. In this exercise, use the mean of all `stepMean` values.

Store the new information (boolean to differentiate between stops (`TRUE`) and moves (`FALSE`)) in a new column named `static`.

:::{.callout-note collapse="true"}

## If you use Git...

Commit your changes with a meaningful commit message. 


:::

### Task 3: Visualize segmented trajectories

Now visualize the segmented trajectory spatially. Just like last week, you can use ggplot with `geom_path()`, `geom_point()` and `coord_equal()`. Assign `colour = static` within `aes()` to distinguish between segments *with* "movement" and *without*.

:::{.callout-note collapse="true"}

## If you use Git...

Commit your changes with a meaningful commit message. 


:::

### Task 4: Segment-based analysis

In applying @laube2011, we've come as far as step b) in @fig-laubeimg. In order to complete the last steps (c and d), we need a *unique* ID for each segment that we can use as a grouping variable. The following function does just that (it assigns unique IDs based on the column `static` which you created in Task 2). You will learn about functions next week. For now, just copy the following code chunk into your script and run it.

```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}
```

You can use the newly created function `rle_id` to assign unique IDs to subtrajectories (as shown below). Visualize the *moving* segments by colourizing them by `segment_ID`. 
Then use `segment_ID` as a grouping variable to determine the segments duration and remove short segments (e.g. segments with a duration < 5 Minutes) 

```{r}
#| eval: false

your_data_frame <- your_data_frame |>
    mutate(segment_id = rle_id(static))
```

:::{.callout-note collapse="true"}

## If you use Git...

Commit your changes with a meaningful commit message. 


:::

